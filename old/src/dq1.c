/**********************************************************
** DQ1 版「復活の呪文」解析＆作成
** @(#) $Header: dq1.c, v 0.3 1998/05/31 yotti $
**
** 漢字コードは Shift_JIS か EUC-JP を仮定
** （どっちでもいいわけでは、ないが）
***********************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>	/* for memcmp() */
#include "dq1.h"

#define MyAryNum(X) (sizeof(X)/sizeof(*X))

/* 五十音用 型 */
struct moji {
	char ch[3] ;
	int num ;
} ;

/* 名前用五十音 */
static struct moji name_alphabet[] = {
	{"０",  0}, {"１",  1}, {"２",  2}, {"３",  3}, {"４",  4},
	{"５",  5}, {"６",  6}, {"７",  7}, {"８",  8}, {"９",  9},
	{"あ", 10}, {"い", 11}, {"う", 12}, {"え", 13}, {"お", 14},
	{"か", 15}, {"き", 16}, {"く", 17}, {"け", 18}, {"こ", 19},
	{"さ", 20}, {"し", 21}, {"す", 22}, {"せ", 23}, {"そ", 24},
	{"た", 25}, {"ち", 26}, {"つ", 27}, {"て", 28}, {"と", 29},
	{"な", 30}, {"に", 31}, {"ぬ", 32}, {"ね", 33}, {"の", 34},
	{"は", 35}, {"ひ", 36}, {"ふ", 37}, {"へ", 38}, {"ほ", 39},
	{"ま", 40}, {"み", 41}, {"む", 42}, {"め", 43}, {"も", 44},
	{"や", 45}, {"ゆ", 46}, {"よ", 47},
	{"ら", 48}, {"り", 49}, {"る", 50}, {"れ", 51}, {"ろ", 52},
	{"わ", 53}, {"を", 54}, {"ん", 55},
	{"っ", 56}, {"ゃ", 57}, {"ゅ", 58}, {"ょ", 59},
	{"゛", 60}, {"゜", 61}, {"－", 62}, {"　", 63},
} ;

/* 名前読み換えデータ・濁点編(60) */
static struct moji name_dakuten[] = {
	{"が", 15}, {"ぎ", 16}, {"ぐ", 17}, {"げ", 18}, {"ご", 19},
	{"ざ", 20}, {"じ", 21}, {"ず", 22}, {"ぜ", 23}, {"ぞ", 24},
	{"だ", 25}, {"ぢ", 26}, {"づ", 27}, {"で", 28}, {"ど", 29},
	{"ば", 35}, {"び", 36}, {"ぶ", 37}, {"べ", 38}, {"ぼ", 39},
} ;

/* 名前読み換えデータ・半濁点編(61) */
static struct moji name_handakuten[] = {
	{"ぱ", 35}, {"ぴ", 36}, {"ぷ", 37}, {"ぺ", 38}, {"ぽ", 39},
} ;

/* 復活の呪文用五十音 */
static struct moji jumon_alphabet[] = {
	{"あ",  0}, {"い",  1}, {"う",  2}, {"え",  3}, {"お",  4},
	{"か",  5}, {"き",  6}, {"く",  7}, {"け",  8}, {"こ",  9},
	{"さ", 10}, {"し", 11}, {"す", 12}, {"せ", 13}, {"そ", 14},
	{"た", 15}, {"ち", 16}, {"つ", 17}, {"て", 18}, {"と", 19},
	{"な", 20}, {"に", 21}, {"ぬ", 22}, {"ね", 23}, {"の", 24},
	{"は", 25}, {"ひ", 26}, {"ふ", 27}, {"へ", 28}, {"ほ", 29},
	{"ま", 30}, {"み", 31}, {"む", 32}, {"め", 33}, {"も", 34},
	{"や", 35}, {"ゆ", 36}, {"よ", 37},
	{"ら", 38}, {"り", 39}, {"る", 40}, {"れ", 41}, {"ろ", 42},
	{"わ", 43},
	{"が", 44}, {"ぎ", 45}, {"ぐ", 46}, {"げ", 47}, {"ご", 48},
	{"ざ", 49}, {"じ", 50}, {"ず", 51}, {"ぜ", 52}, {"ぞ", 53},
	{"だ", 54}, {"ぢ", 55}, {"づ", 56}, {"で", 57}, {"ど", 58},
	{"ば", 59}, {"び", 60}, {"ぶ", 61}, {"べ", 62}, {"ぼ", 63},

	/* 0 - 63 までは、順番に並べておく必要がある */
	/* 表示(復元)の際にも使うから */

	/* 読み換える文字 */
	{"ぁ",  0}, {"ぃ",  1}, {"ぅ",  2}, {"ぇ",  3}, {"ぉ",  4},
	{"ゃ", 35}, {"ゅ", 36}, {"ょ", 37}, {"っ", 17},

	{"？", 64},

} ;


/* チェックコード計算用マジックナンバー */
static int cnst[] = {
	0x88, 0xc4, 0x62, 0x31, 0x08, 0x84, 0x42, 0x21,
	0x98, 0xcc, 0xe6, 0x73, 0xa9, 0xc4, 0x62, 0x31,
	0x5a, 0xad, 0xc6, 0x63, 0xa1, 0xc0, 0x60, 0x30,
	0x38, 0x9c, 0x4e, 0xa7, 0xc3, 0xf1, 0x68, 0xb4,
	0xd0/*?*/, 0x68, 0xb4, 0x5a, 0x2d/*?*/, 0x06, 0x83, 0x51,
	0x20, 0x10, 0x08, 0x84, 0x42, 0xa1, 0x40, 0xa0,
	0xf9, 0xec, 0xf6, 0x7b, 0xad, 0xc6, 0xe3, 0x61,
	0x81, 0xd0, 0x68, 0xb4, 0xda, 0x6d, 0xa6, 0xd3,
	0xb2, 0xd9, 0xfc, 0xfe, 0xff, 0xef, 0x67, 0x23,
	0x34, 0x1a, 0x0d, 0x96, 0x4b, 0x35, 0x8a, 0x45,
	0xaa, 0xd5, 0x7a, 0x3d, 0x8e, 0x47, 0xb3, 0x49,
	0xa1, 0x40, 0xa0, 0x50, 0xa8, 0xd4, 0xea, 0x75,
	0xa0, 0xd0, 0x68, 0xb4, 0x5a, 0xad, 0xc6, 0x63,
	0x7e, 0xbf, 0xcf, 0xf7, 0x6b, 0xa5, 0xc2, 0x61,
} ;

/* アイテム一覧 */
char *dq1_item_list[16] = {
	"なし", "たいまつ", "せいすい", "キメラのつばさ",
	"りゅうのうろこ","ようせいのふえ","せんしのゆびわ","ロトのしるし",
	"おうじょのあい","のろいのベルト","ぎんのたてごと","しのくびかざり",
	"たいようのいし","あまぐものつえ","にじのしずく",
	"（不明）",
} ;

/* 武器一覧 */
char *dq1_wapon_list[8] = {
	"なし","たけざお","こんぼう","どうのつるぎ",
	"てつのおの","はがねのつるぎ","ほのおのつるぎ","ロトのつるぎ"
} ;

/* 鎧一覧 */
char *dq1_armor_list[8] = {
	"なし","ぬののふく","かわのふく","くさりかたびら",
	"てつのよろい","はがねのよろい","まほうのよろい","ロトのよろい"
} ;

/* 盾一覧 */
char *dq1_shild_list[4] = {
	"なし","かわのたて","てつのたて","みかがみのたて"
} ;

/* レベル（経験値）一覧 */
/* Lv 1 の必要経験値 = dq1_level_list[0]   */
/* Lv n の必要経験値 = dq1_level_list[n-1] */
int dq1_level_list[30] = {
	    0,    7,   23,   47,  110,  220,  450,  800, 1300, 2000,
	 2900, 4000, 5500, 7500,10000,13000,17000,21000,25000,29000,
	33000,37000,41000,45000,49000,53000,57000,61000,65000,65535,
} ;


/**********************************************************
** 経験値からレベルを求める
** （内部関数）
***********************************************************/
static int get_level(int exp)
{
	int i ;

	for ( i = MyAryNum(dq1_level_list) -1 ; i >= 0 ; i -- ) {
		if ( dq1_level_list[i] <= exp ) {
			return i+1 ;
		}
	}

	return 0 ;

}


/**********************************************************
** かなを、数字に直す
** （内部関数）
***********************************************************/
static int kana2num(
	char *kana,
	struct moji *gojuon,
	int gojuon_max)
{
	int i ;

	for ( i = 0 ; i < gojuon_max; i ++ ) {
		if ( kana[0] == gojuon[i].ch[0] &&
		     kana[1] == gojuon[i].ch[1] ) {
			return gojuon[i].num ;
		}
	}

	/* 不正な値なら -1 を返す */
	return -1 ;
}


/**********************************************************
** 名前(int[4]) を文字列(char[9])に変換
***********************************************************/
void dq1_cnv_int2name(
	int *name1,
	char *name2)
{
	int i ;

	for ( i = 0 ; i < 4 ; i ++ ) {
		*name2++ = name_alphabet[name1[i]].ch[0] ;
		*name2++ = name_alphabet[name1[i]].ch[1] ;
	}
	*name2 = '\0' ;
}


/**********************************************************
** 名前(char*) を数字(int[4])に変換
** 不正な文字があれば、その時点で変換を中止する
***********************************************************/
void dq1_cnv_name2int(
	char *name1,
	int *name2)
{
	int i ;

	for ( i = 0 ; i < 4 ; i ++ ) {
		name2[i] = 63 ;	/* スペース */
	}

	for ( i = 0 ; i < 4 ; ) {
		int rc ;

		if ( *name1 == '\0' ) {
			break ;
		}

		rc = kana2num(name1, name_alphabet, MyAryNum(name_alphabet)) ;

		if ( rc != -1 ) {
			name1 += 2 ;
			name2[i++] = rc ;
			continue ;
		}

		rc = kana2num(name1, name_dakuten, MyAryNum(name_dakuten)) ;
		if ( rc != -1 ) {
			name1 += 2 ;
			name2[i++] = rc ;
			if ( i == 4 ) break ;
			name2[i++] = 60 ; /* 濁点 */
			continue ;
		}

		rc = kana2num(name1, name_handakuten, MyAryNum(name_handakuten)) ;
		if ( rc != -1 ) {
			name1 += 2 ;
			name2[i++] = rc ;
			if ( i == 4 ) break ;
			name2[i++] = 61 ; /* 半濁点 */
			continue ;
		}

		/* 不正な文字 */
		break ;
	}
}


/**********************************************************
** 呪文(int*) を文字列(char[47])に変換
***********************************************************/
void dq1_cnv_int2pswd(
	int *pswd1,
	char *pswd2)
{
	int i ;

	for ( i = 0 ; i < 20 ; i ++ ) {
		*pswd2++ = jumon_alphabet[pswd1[i]].ch[0] ;
		*pswd2++ = jumon_alphabet[pswd1[i]].ch[1] ;

		if ( i == 4 || i == 11 || i == 16 ) {
			*pswd2++ = ' ' ;
			*pswd2++ = ' ' ;
		}
	}
	*pswd2 = '\0' ;
}


/**********************************************************
** 呪文(char*) を数字(int[20])に変換
***********************************************************/
int dq1_cnv_pswd2int(
	char *pswd1,
	int *pswd2)
{
	int i ;
	int err = 0 ;

	for ( i = 0 ; i < 20 ; i ++ ) {
		pswd2[i] = -1 ;
	}

	for ( i = 0 ; i < 20 ; ) {
		int w, rc ;

		w = *pswd1 ;
		if ( w == '\0' ) {
			/* 長さが足りない */
			return 0 ;
		}
		if ( w == ' ' ) {
			/* スペースは読み飛ばす */
			pswd1 ++ ;
			continue ;
		}
		if ( memcmp(pswd1, "　", 2) == 0 ) {
			pswd1 += 2 ;
			continue ;
		}
		rc = kana2num(pswd1, jumon_alphabet, MyAryNum(jumon_alphabet)) ;
		pswd2[i] = rc ;
		if ( rc == -1 ) {
			/* 不正な文字がある */
			return 0 ;
		}
		if ( rc == 64 ) {
			err = 1 ;
		}
		i ++ ;
		pswd1 += 2 ;
	}

	if ( err ) {
		return 2 ;	/* 「？」が含まれている */
	}
	return 1 ; /* 正常 */
}


/**********************************************************
** DQ1 用復活の呪文を作成する
***********************************************************/
void dq1_make_pswd(
	struct dq1pswd *dq1,
	int *pswd)
{
	int i, j, work ;
	int data[20] ;
	int code[15] ;

	code[0] =
		( dq1->item[1] << 4 ) |
		  dq1->item[0]        ;
	code[1] =
		( dq1->flag1   << 7 ) |
		( dq1->name[1] << 1 ) |
		  dq1->flag2          ;
	code[2] = ( dq1->exp >> 8 ) & 0xff ;
	code[3] =
		( dq1->item[5] << 4 ) |
		  dq1->item[4]        ;
	code[4] =
		( dq1->key     << 4 ) |
		  dq1->herb           ;
	code[5] = ( dq1->gold >> 8 ) & 0xff ;
	code[6] = 
		( dq1->wapon   << 5 ) |
		( dq1->armor   << 2 ) |
		  dq1->shild          ;
	code[7] =
		(( dq1->crypt << 5 ) & 0x80 ) |
		( dq1->flag3   << 6 ) |
		  dq1->name[3]        ;
	code[8] =
		( dq1->item[7] << 4 ) |
		  dq1->item[6]        ;
	code[9] =
		( dq1->name[0] << 2 ) |
		( dq1->flag4   << 1 ) |
		(( dq1->crypt >> 1 ) & 0x01 ) ;
	code[10] = dq1->gold & 0xff ;
	code[11] =
		( dq1->item[3] << 4 ) |
		  dq1->item[2]        ;
	code[12] =
		(( dq1->crypt << 7 ) & 0x80 ) |
		( dq1->flag5   << 6 ) |
		  dq1->name[2]        ;
	code[13] = dq1->exp & 0xff ;

	code[14] = 0 ;
	/* チェックコードを計算する */
	for ( i = 0 ; i < 14 ; i ++ ) {
		for ( j = 0 ; j < 8 ; j ++ ) {
			if ( code[i] & ( 0x80 >> j ) && cnst[i*8+j] != 0x00 ) {
				code[14] ^= cnst[i*8+j] ;
			}
		}
	}

	/* 8bit 毎の code[] を、 6bit 毎の data[] に変換 */
	j = 0 ;
	for ( i = 14 ; i >= 0 ; i -=3 ) {
		long w ;

		w = (code[i-2]<<16)|(code[i-1]<<8)|(code[i]) ;
		data[j++] =   w         & 0x3f ;
		data[j++] = ( w >>  6 ) & 0x3f ;
		data[j++] = ( w >> 12 ) & 0x3f ;
		data[j++] = ( w >> 18 ) & 0x3f ;
	}

	/* 4 を足し、data[] を累計していく */
	work = 0 ;
	for ( i = 0 ; i < 20 ; i ++ ) {
		pswd[i] = ( data[i] + work + 4 ) & 0x3f ;
		work = pswd[i] ;
	}

	return ;
}


/**********************************************************
** DQ1 用復活の呪文を解析し、構造体に格納する
** 呪文が正しければ true(1) 、不正なら false(0) を返す
***********************************************************/
int dq1_ana_pswd(
	int *pswd,
	struct dq1pswd *dq1)
{
	int i, j ;
	int data[20] ;
	int code[15] ;
	struct dq1pswd wk_dq1 ;

	if ( dq1 == NULL ) {
		dq1 = &wk_dq1 ;
	}

	/* 4 を引き、前後の文字の差分を取る */
	for ( i = 19 ; i >= 1 ; i -- ) {
		data[i] = ( pswd[i] - pswd[i-1] -4 ) & 0x3f ;
	}
	data[0] = ( pswd[0] - 4 ) & 0x3f ;

	/* 6bit 毎の data[] を、 8bit 毎の code[] に変換 */
	j = 0 ;
	for ( i = 19 ; i >= 0 ; i -=4 ) {
		long w ;

		w = (data[i]<<18)|(data[i-1]<<12)|(data[i-2]<<6)|data[i-3] ;
		code[j++] = ( w >> 16 ) & 0xff ;
		code[j++] = ( w >>  8 ) & 0xff ;
		code[j++] =   w         & 0xff ;
	}

	/* チェックコードを計算する */
	for ( i = 0 ; i < 14 ; i ++ ) {
		for ( j = 0 ; j < 8 ; j ++ ) {
			if ( code[i] & ( 0x80 >> j ) && cnst[i*8+j] != 0x00 ) {
				code[14] ^= cnst[i*8+j] ;
			}
		}
	}

	dq1->check = code[14] ;

	dq1->name[0] = (code[ 9]>>2)&0x3f ;
	dq1->name[1] = (code[ 1]>>1)&0x3f ;
	dq1->name[2] = (code[12]   )&0x3f ;
	dq1->name[3] = (code[ 7]   )&0x3f ;

	dq1->wapon   = (code[ 6]>>5)&0x07 ;
	dq1->armor   = (code[ 6]>>2)&0x07 ;
	dq1->shild   =  code[ 6]    &0x03 ;

	dq1->item[0] =  code[ 0]    &0x0f ;
	dq1->item[1] = (code[ 0]>>4)&0x0f ;
	dq1->item[2] =  code[11]    &0x0f ;
	dq1->item[3] = (code[11]>>4)&0x0f ;
	dq1->item[4] =  code[ 3]    &0x0f ;
	dq1->item[5] = (code[ 3]>>4)&0x0f ;
	dq1->item[6] =  code[ 8]    &0x0f ;
	dq1->item[7] = (code[ 8]>>4)&0x0f ;

	dq1->key     = (code[ 4]>>4)&0x0f ;
	dq1->herb    =  code[ 4]    &0x0f ;

	dq1->exp     = code[2]*256 + code[13] ;
	dq1->gold    = code[5]*256 + code[10] ;

	dq1->flag1   = (code[ 1]>>7)&0x01 ;
	dq1->flag2   =  code[ 1]    &0x01 ;
	dq1->flag3   = (code[ 7]>>6)&0x01 ;
	dq1->flag4   = (code[ 9]>>1)&0x01 ;
	dq1->flag5   = (code[12]>>6)&0x01 ;

	dq1->crypt   = 
		((code[ 7]>>5)&0x04) |
		((code[ 9]<<1)&0x02) |
		((code[12]>>7)&0x01) ;

	dq1->level = get_level(dq1->exp) ;

	/* 呪文が正しいかどうかをチェック */
	if ( dq1->check != 0 ||
	     dq1->key   >  6 ||
	     dq1->herb  >  6 ) {
		return 0 ; /* ダメ */
	}

	for ( i = 0 ; i < 8 ; i ++ ) {
		if ( dq1->item[i] >= 15 ) {
			return 0 ; /* ダメ */
		}
	}

	return 1 ;
}
